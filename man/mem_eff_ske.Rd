% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/util.R
\name{mem_eff_ske}
\alias{mem_eff_ske}
\title{Memory Efficient Sketching}
\usage{
mem_eff_ske(file_path, n, p, m, method = "block", num_blocks = 10, K = 0, b = NULL)
}
\arguments{
\item{file_path}{Path to CSV file containing data (last column should be y)}

\item{n}{Number of rows in the dataset}

\item{p}{Number of features (excluding response)}

\item{m}{Main sketch size}

\item{method}{Processing method: "full" or "block"}

\item{num_blocks}{Number of blocks for block processing (default = 10)}

\item{K}{Number of reduced-size sketches to generate (default = 0, no reduced sketches)}

\item{b}{Size of each reduced sketch (required if K > 0)}
}
\value{
List containing:
\item{sketch_X}{Main sketched design matrix (size m)}
\item{sketch_y}{Main sketched response vector (size m)}
\item{reduced_sketches_X}{List of K reduced sketched design matrices (each size b)}
\item{reduced_sketches_y}{List of K reduced sketched response vectors (each size b)}
\item{processing_time}{Time taken for processing}
\item{loading_time}{Time taken for data loading}
}
\description{
Performs memory-efficient sketching for large datasets that cannot be fully 
loaded into RAM. This function is designed specifically for situations where 
the dataset is too large to fit in memory, and processes data in blocks or 
streaming fashion by reading directly from disk.
}
\examples{
\dontrun{
# Create test data
n <- 10000; p <- 100; m <- 500; K <- 10; b <- 200
set.seed(123)
X <- matrix(rnorm(n * p), n, p)
true_beta <- rnorm(p)
y <- X \%*\% true_beta + rnorm(n, sd = 0.1)
data <- cbind(X, y)
colnames(data) <- c(paste0("X", 1:p), "y")
write.csv(data, "test_data.csv", row.names = FALSE)

# Test mem_eff_ske with main sketch + reduced sketches
result <- mem_eff_ske("test_data.csv", n, p, m, K = K, b = b)

# Check results
cat("Main sketch dimensions:", dim(result$sketch_X), "\\n")
cat("Number of reduced sketches:", length(result$reduced_sketches_X), "\\n")
cat("Reduced sketch dimensions:", dim(result$reduced_sketches_X[[1]]), "\\n")

# Use with general inference
c_vec <- rep(1, p)  # sum of coordinates
theta_m <- sum(c_vec * qr.solve(result$sketch_X, result$sketch_y))
theta_b_list <- lapply(1:K, function(k) {
  sum(c_vec * qr.solve(result$reduced_sketches_X[[k]], result$reduced_sketches_y[[k]]))
})

# Apply general inference
# inference_result <- general_inference(theta_m, theta_b_list, tau_m, tau_b, method = "subrand")

# Cleanup
file.remove("test_data.csv")
}
}
